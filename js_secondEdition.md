# JavaScript. Ядро: 2-ое издание
_Dmitry Soshnikov  in ECMAScript	| 2017-12-05_
[Original](http://dmitrysoshnikov.com/ecmascript/javascript-the-core-2nd-edition-rus/)

Данная статья описывает рантайм-систему ES2017+.

**Обратите внимание:** последнюю версию [ECMAScript](https://tc39.github.io/ecma262/) спецификации можно найти на сайте комитета TC-39.

Мы начинаем нашу дискуссию с рассмотрения концепции объекта, являющейся фундаментальной абстракцией в ECMAScript.

## Объект
ECMAScript — это объектно-ориентированный язык программирования с прототипной организацией, имеющий концепцию объекта в качестве базовой абстракции.

**Определение 1: Объект:** _Объект — это коллекция свойств_, имеющая также связанный с ней _объект-прототип_. Прототипом может быть также другой объект, или же значение null.

Рассмотрим простейшую схему объекта, с которой будем работать в последующих описаниях. На свой прототип объект ссылается посредством внутреннего свойства [[Prototype]], которое доступно в пользовательском коде через свойство __proto__.

Для кода:
```javascript
let point = {
  x: 10,
  y: 20,
};
```
мы имеем следующую структуру с двумя явными собственными свойствами и одним неявным (внутренним) свойством __proto__, которое является ссылкой на прототип объекта _point_:

![alt text](http://dmitrysoshnikov.com/wp-content/uploads/2017/11/js-object.png "Схема 1. Простейший объект с прототипом.")
_Схема 1. Простейший объект с прототипом._

**Обратите внимание:** объекты также могут хранить _символы_. Вы можете получить больше информации о символах в этой документации.

Прототипные объекты используются для реализации _наследования_ при помощи механизма **_динамической диспетчеризации (dynamic dispatch)_**. Рассмотрим понятие цепи прототипов, чтобы увидеть этот механизм в действии.

## Прототип
Каждый объект при создании получает свой прототип. Если прототип не задан явно, объекты получают базовый прототип по-умолчанию в качестве объекта наследнования.

**Определение 2: Прототип:** _Прототип_ — это объект-делегат, используемый для реализации _прототипного наследования_.

При создании объекта, его прототип может быть установлен явно через свойство __proto__, или же с помощью метода _Object.create_:
```javascript
// Базовый объект.
let point = {
  x: 10,
  y: 20,
};
 
// Наследуем от объекта `point`.
let point3D = {
  z: 30,
  __proto__: point,
};
 
console.log(
  point3D.x, // 10, унаследованное
  point3D.y, // 20, унаследованное
  point3D.z  // 30, собственное
);
```
**Обратите внимание:** по-умолчанию объекты получают Object.prototype в качестве наследуемого объекта.

Любой объект может быть использован в качестве прототипа другого объекта, и сам прототип может иметь свой собственный прототип. Если прототип имеет непустую ссылку на свой прототип, и т.д., такая связка называется **_цепью прототипов (prototype chain)_**.

**Определение 3: Цепь прототипов:** _Цепь прототипов_ — это _конечная_ цепь объектов, используемая для реализации _наследования и разделяемых свойств_.

![alt text](http://dmitrysoshnikov.com/wp-content/uploads/2017/11/prototype-chain.png "Схема 2. Цепь прототипов.")
_Схема 2. Цепь прототипов._

Здесь правило очень простое: если свойство не найдено в самом объекте, осуществляется попытка разрешить (найти) это свойство в прототипе; в прототипе прототипа, и т.д. — до тех пор, пока вся цепь прототипов не будет рассмотрена.

Данный механизм известен как динамическая диспетчеризация (dynamic dispatch) или делегация (delegation).

**Определение 4: Делегация:** механизм, используемый для разрешения свойств в цепи наследования. Процесс осуществляется во время исполнения программы, поэтому также называется **динамической диспетчеризацией**.

**Обратите внимание:** в отличие от статической дипетчеризации, когда ссылки разрешаются во время компиляции, динамическая диспетчеризация всегда разрешает ссылки во время исполнения программы.

Eсли свойство в итоге не найдено во всей цепи прототипов, возвращается значение _undefined_:
```javascript
// "Пустой" объект.
let empty = {};
 
console.log(
 
  // функция, из прототипа по-умолчанию
  empty.toString,
 
  // undefined
  empty.x,
 
);
```

Как мы видим, обычный объект никогда не является пустым — он всегда наследует что-то из _Object.prototype_. Чтобы создать беспрототипный словарь, необходимо явно установить его прототип в _null_:

```javascript
// Не наследуем ни от кого.
let dict = Object.create(null);
 
console.log(dict.toString); // undefined
```
Механизм динамической диспетчеризации также позволяет мутировать цепь наследования и менять объект-делегат:

```javascript
let protoA = {x: 10};
let protoB = {x: 20};
 
// То же, что и `let objectC = {__proto__: protoA};`:
let objectC = Object.create(protoA);
console.log(objectC.x); // 10
 
// Изменяем прототип:
Object.setPrototypeOf(objectC, protoB);
console.log(objectC.x); // 20
```

**Обратите внимание:** несмотря на то, что свойство _ __proto__ _ на сегодняшний день стандартизовано, и проще для объяснения материала, на практике рекомендовано использование API методов для манипуляции с прототипами, таких как _Object.create, Object.getPrototypeOf, Object.setPrototypeOf_, и схожих в модуле Reflect.

На примере _Object.prototype_, мы видим, что один и тот же прототип может наследоваться многими объектами. На этом принципе простроено классовое наследование в ECMAScript. Давайте рассмотрим пример и заглянем в детали реализации абстракции “класс” в JS.
